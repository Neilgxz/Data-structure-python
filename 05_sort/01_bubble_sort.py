
"""
冒泡排序 最优O(n) 最坏 O(n^2) 稳定 原地排序（空间复杂度O(1)）
平均复杂度：
对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。
比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。
如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。
我这里还有一种思路，通过“有序度”和“逆序度”这两个概念来进行分析。
有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：
有序元素对：a[i] <= a[j], 如果i < j。
同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，
比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度
逆序度的定义正好跟有序度相反（默认从小到大为有序）
关于这三个概念，我们还可以得到一个公式：逆序度 = 满有序度 - 有序度。
我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。
我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3，2，1 ，
其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。
冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。
不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度。此例中就是 15–3=12，要进行 12 次交换操作。
对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？
最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。
最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。
换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。
"""
from typing import List
def bubble_sort(alist: List[int]):
    count = len(alist) - 1
    while count > 0:
        lastexchangeindex = 0
        for i in range(count):
            if alist[i] > alist[i + 1]:
                alist[i], alist[i + 1] = alist[i + 1], alist[i]
                lastexchangeindex = i
        count = lastexchangeindex

# def bubble_sort_1(a: List[int]):
#     length = len(a)
#     if length <= 1:
#         return
#     for i in range(length):
#         made_swap = False
#         for j in range(length - i - 1):
#             if a[j] > a[j + 1]:
#                 a[j], a[j + 1] = a[j + 1], a[j]
#                 made_swap = True
#         if not made_swap:
#             break

if __name__ == "__main__":
    li = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print(li)
    bubble_sort(li)
    # bubble_sort_1(li)
    print(li)